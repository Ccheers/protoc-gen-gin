// Code generated by github.com/Ccheers/protoc-gen-gin. DO NOT EDIT.

package v1

import (
	context "context"
	fmt "fmt"
	gin "github.com/gin-gonic/gin"
	middleware "github.com/go-kratos/kratos/v2/middleware"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	metadata "google.golang.org/grpc/metadata"
	url "net/url"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the Ccheers/protoc-gen-gin package it is being compiled against.

// blog service is a blog demo
type BlogServiceGinServer interface {
	GetArticles(context.Context, *GetArticlesReq) (*GetArticlesResp, error)
	CreateArticle(context.Context, *Article) (*Article, error)
}

func RegisterBlogServiceGinServer(r gin.IRoutes, srv BlogServiceGinServer) {
	r.GET("/v1/author/:author_id/articles", GetArticles_0_GinHandler(srv))    // 获取文章列表
	r.GET("/v1/articles", GetArticles_1_GinHandler(srv))                      // 获取文章列表
	r.POST("/v1/author/:author_id/articles", CreateArticle_0_GinHandler(srv)) // 创建文章
}
func GetArticles_0_GinHandler(srv BlogServiceGinServer) func(ctx *gin.Context) {
	return func(ctx *gin.Context) {

		var in GetArticlesReq
		var err error

		var EncodeResponseFunc = http.DefaultResponseEncoder
		var EncodeErrorFunc = http.DefaultErrorEncoder

		defer func() {
			if err != nil {
				EncodeErrorFunc(ctx.Writer, ctx.Request, err)
			}
		}()

		out, ok := ctx.Get("kratos.http.encoder")
		if ok {
			EncodeResponseFunc = out.(http.EncodeResponseFunc)
		}

		out, ok = ctx.Get("kratos.http.error")
		if ok {
			EncodeErrorFunc = out.(http.EncodeErrorFunc)
		}

		var values = make(url.Values)
		for _, param := range ctx.Params {
			values.Add(param.Key, param.Value)
		}
		if err := binding.BindQuery(values, &in); err != nil {
			ctx.Error(err)
			return
		}

		if err := binding.BindQuery(ctx.Request.URL.Query(), &in); err != nil {
			ctx.Error(err)
			return
		}

		md := metadata.New(nil)

		for k, v := range ctx.Request.Header {
			md.Set(k, v...)
		}

		for k, v := range ctx.Keys {
			if stringer, ok := v.(fmt.Stringer); ok {
				md.Set(k, stringer.String())
			}
		}

		newCtx := metadata.NewIncomingContext(ctx, md)

		var ms []middleware.Middleware
		out, ok = ctx.Get("kratos.middleware.provider")
		if ok {
			ms = out.([]middleware.Middleware)
		}

		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetArticles(ctx, req.(*GetArticlesReq))
		}

		out, err = middleware.Chain(ms...)(handler)(newCtx, &in)
		if err != nil {
			ctx.Error(err)
			return
		}

		EncodeResponseFunc(ctx.Writer, ctx.Request, out.(*GetArticlesResp))
	}
}
func GetArticles_1_GinHandler(srv BlogServiceGinServer) func(ctx *gin.Context) {
	return func(ctx *gin.Context) {

		var in GetArticlesReq
		var err error

		var EncodeResponseFunc = http.DefaultResponseEncoder
		var EncodeErrorFunc = http.DefaultErrorEncoder

		defer func() {
			if err != nil {
				EncodeErrorFunc(ctx.Writer, ctx.Request, err)
			}
		}()

		out, ok := ctx.Get("kratos.http.encoder")
		if ok {
			EncodeResponseFunc = out.(http.EncodeResponseFunc)
		}

		out, ok = ctx.Get("kratos.http.error")
		if ok {
			EncodeErrorFunc = out.(http.EncodeErrorFunc)
		}

		if err := binding.BindQuery(ctx.Request.URL.Query(), &in); err != nil {
			ctx.Error(err)
			return
		}

		md := metadata.New(nil)

		for k, v := range ctx.Request.Header {
			md.Set(k, v...)
		}

		for k, v := range ctx.Keys {
			if stringer, ok := v.(fmt.Stringer); ok {
				md.Set(k, stringer.String())
			}
		}

		newCtx := metadata.NewIncomingContext(ctx, md)

		var ms []middleware.Middleware
		out, ok = ctx.Get("kratos.middleware.provider")
		if ok {
			ms = out.([]middleware.Middleware)
		}

		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetArticles(ctx, req.(*GetArticlesReq))
		}

		out, err = middleware.Chain(ms...)(handler)(newCtx, &in)
		if err != nil {
			ctx.Error(err)
			return
		}

		EncodeResponseFunc(ctx.Writer, ctx.Request, out.(*GetArticlesResp))
	}
}
func CreateArticle_0_GinHandler(srv BlogServiceGinServer) func(ctx *gin.Context) {
	return func(ctx *gin.Context) {

		var in Article
		var err error

		var DecodeRequestFunc = http.DefaultRequestDecoder
		var EncodeResponseFunc = http.DefaultResponseEncoder
		var EncodeErrorFunc = http.DefaultErrorEncoder

		defer func() {
			if err != nil {
				EncodeErrorFunc(ctx.Writer, ctx.Request, err)
			}
		}()

		out, ok := ctx.Get("kratos.http.encoder")
		if ok {
			EncodeResponseFunc = out.(http.EncodeResponseFunc)
		}

		out, ok = ctx.Get("kratos.http.decoder")
		if ok {
			DecodeRequestFunc = out.(http.DecodeRequestFunc)
		}

		out, ok = ctx.Get("kratos.http.error")
		if ok {
			EncodeErrorFunc = out.(http.EncodeErrorFunc)
		}

		var values = make(url.Values)
		for _, param := range ctx.Params {
			values.Add(param.Key, param.Value)
		}
		if err := binding.BindQuery(values, &in); err != nil {
			ctx.Error(err)
			return
		}

		if err = DecodeRequestFunc(ctx.Request, &in); err != nil {
			ctx.Error(err)
			return
		}

		md := metadata.New(nil)

		for k, v := range ctx.Request.Header {
			md.Set(k, v...)
		}

		for k, v := range ctx.Keys {
			if stringer, ok := v.(fmt.Stringer); ok {
				md.Set(k, stringer.String())
			}
		}

		newCtx := metadata.NewIncomingContext(ctx, md)

		var ms []middleware.Middleware
		out, ok = ctx.Get("kratos.middleware.provider")
		if ok {
			ms = out.([]middleware.Middleware)
		}

		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateArticle(ctx, req.(*Article))
		}

		out, err = middleware.Chain(ms...)(handler)(newCtx, &in)
		if err != nil {
			ctx.Error(err)
			return
		}

		EncodeResponseFunc(ctx.Writer, ctx.Request, out.(*Article))
	}
}
